# -final

#### final 이 붙으면 더는 값을 변경할 수 없음.
#### final은 class, method를 포함한 여러 곳에 붙을 수 있음.


### -final 지역 변수
```java
public class FinalLocalMain {
    public static void main(String[] args) {
        final int data1;
        data1 = 10; //final이 붙으면 최초 한번 초기화 가능

        final int data2 = 20; // 컴파일 에러 -> 이후 값을 변경시 컴파일 오류

        method(10);

    }
    static void method(final int parameter){
        //parameter=20;
    }
}
```
#### final을 지역 변수에 설정할 경우 -> 최초 한번만 할당 가능, 이후 값을 변경시 컴파이 오류 발생.
#### final이 붙으면 메서드 내부에서 매개변수의 값을 변경할 수 없다. 따라서 메서드 호출 시점에 사용 된 값이 끝까지 사용됨.


```java
    public static void main(String[] args) {
        //생성자를 통한 final 값 할당
        System.out.println("생성자 초기화");
        ConstructInit cons1 = new ConstructInit(10);
        ConstructInit cons2 = new ConstructInit(20);
        System.out.println(cons1.value);
        System.out.println(cons2.value);

        //final 필드 - 필드 초기화
        System.out.println("필드 초기화");
        FieldInit fieldInit1 = new FieldInit();
        FieldInit fieldInit2 = new FieldInit();
        FieldInit fieldInit3 = new FieldInit();
        System.out.println(fieldInit1.value);
        System.out.println(fieldInit2.value);
        System.out.println(fieldInit3.value);

        //상수
        System.out.println("상수");
        System.out.println(FieldInit.CONST_VALUE);

    }
```
#### 생성자를 통해 값을 할당할 경우 -> 최초 한번은 생성자를 통해 각 객체마다 다른 값을 할당 가능.
#### 그러나 이후에는 값을 변경할 수 없음. ex). cons1.value=20 => 불가능

#### 필드에서 이미 final 값이 초기화 되어 있는 경우, 이 후에 값을 변경 불가.

# -static final
#### final 키워드는 이미 값이 정해져 있어, 더 이상 값을 할당 불가능 하다 하였음. 따라서, 각 객체를 생성하여 값을 할당할 경우
#### 메모리에는 인스턴스 수 만큼 힙 영역에 쌓이게 될 텐데, 여기서 필드 값은 어차피 모두 10이기 때문에 메모리가 낭비되게 됨.

#### 결국 같은 값이 계속 생성되는 것은 메모리 낭비임! -> 해결책은 바로 static 영역.
#### static final을 사용하면 해당 필드 값은 static 영역에 존재하게 되므로 -> 중복과 메모리 비효율 문제를 모두 해결 가능하다.
#### 따라서 이러한 이유로 final 필드를 사용하게 된다면 static을 붙혀서 사용하는 것이 더 효과적

# -상수(Constant)
#### 상수는 변하지 않고 항상 일정한 값을 갖는 수. -> 자바에서는 단 하나만 존재하는 변하지 않는 고정된 값을 지칭

### 특징 
#### 1. static final 키워드 사용.
#### 2. 변수는 모두 대문자를 사용하고 합성어 구분은 _(언더스코어)로 구분.
#### 3. 필드를 직접 접근해서 사용한다.(상수는 기능이 아니라 고정된 값 자체를 사용하는 것이 목적) -> 따라서 필드에 직접 접근해도 데이터가 변하는 문제가 발생하지 않음.

### 상수 선언 예제
```java
xpublic class Constant {
    public static final double PI = 3.1415;

    public static final int HOURS_IN_DAY = 24;
    public static final int MINUTES_IN_HOUR = 60;
    public static final int SECONDS_IN_MINUTE = 60;

    public static final int MAX_USERs = 1000;
}
```
#### 상수는 어플리케이션 전반에 사용되기 때문에 주로 public이나, 특정위치에서만 사용시에는 다른 접근제어자 사용.
#### 상수는 중앙에서 값을 하나로 관라 할 수 있음.
#### 상수는 런타임에서는 변경x, 상수를 변경하려면 프로그램을 종료하고, 코드를 변경한 다음에 프로그램을 다시 실행해야 함.

## -상수를 어떻게 사용할까?
```java
public class ConstantMain1 {
    public static void main(String[] args) {
        System.out.println("프로그램 최대 참여자 수 : " + 1000);
        int currentUserCount = 999;
        process(currentUserCount++);
        process(currentUserCount++);
        process(currentUserCount++);

    }
    private static void process(int currentUserCount){
        System.out.println("참여자 수 : " + currentUserCount);
        if(currentUserCount > 1000){
            System.out.println("대기자로 등록합니다.");
        }else{
            System.out.println("게임에 참가합니다.");
        }
    }
}
```
#### 상수를 적용하지 않았를때, 코드이다. 만약 참가자 수가 수정된다면? 유지보수 관점에서드 메서드에서 최대 인원 수를 늘려주고, 메인에서 최대 참가자수도 늘려주거나 줄여줘야 함
#### 2곳에 변경 포이튼가 발생함. 

## 상수 static final 사용시
```java
public class ConstantMain2 {
    public static void main(String[] args) {
        System.out.println("프로그램 최대 참여자 수 : " + Constant.MAX_USERS);
        int currentUserCount = 999;
        process(currentUserCount++);
        process(currentUserCount++);
        process(currentUserCount++);

    }
    private static void process(int currentUserCount){
        System.out.println("참여자 수 : " + currentUserCount);
        if(currentUserCount > Constant.MAX_USERS){
            System.out.println("대기자로 등록합니다.");
        }else{
            System.out.println("게임에 참가합니다.");
        }
    }
}
```
#### 참여자 수가 늘어 났다고 하더라도 Constant 클래스에 상수 값만 변경하면 됨.

# -final 변수와 참조

#### final을 기본형에서 사용하면 ==> 값을 변경할 수 없다는 뜻, 참조형에서는 어떤 의미일까?

```java
public class FinalRefMain {
    public static void main(String[] args) {
        final Data data = new Data(); // data 는 참조값을 변경할 수 없다는 의미.
        data.value = 10;
        System.out.println(data.value);
        data.value = 20;
        System.out.println(data.value);
    }
```
#### 참조형 변수에 final이 붙으면 더는 참조값을 변경할 수 없다는 의미임. 죽, 다른 객체를 참조할 수 없음.
#### 참조값만 변경을 못할 뿐 해당 변수 이외에는 다른곳에 영향을 주는 것이 아니기때문에 Data 내 final이 아닌 다른 멤버변수는 변경 가능.

### id 처럼 한번 생성하고 나면 다시는 바귀지 않아야할 값이라면 final 키워드를 통해 변수를 만들고 생성자를 통해 한번만 초기화 시키는 식으로 사용해보자.
```java
public class Member {
    private final String id;
    private String name;

    public Member(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public void changeData(String id, String name) {
        //this.id = id; -> 값 변경 불가 final 값이라 생성자에서 id를 초기화 하고 난 시점에서는 더는 값 할당 불가함.
        this.name = name;
    }

    public void print() {
        System.out.println(" id  = " + id + " name: " + name);
    }

}
```